// Copyright (c) Lutz Boeckelmann and Contributors. MIT License - see LICENSE.txt

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using Mono.Cecil;

namespace YADA.Analyzer
{
    /// <summary>
    /// Responsible for retrieving all dependencies of the given type.
    /// </summary>
    internal class TypeAnalyser
    {
        private readonly ITypeFilter m_TypeFilter;
        public TypeAnalyser(ITypeFilter typeFilter = null)
        {
            m_TypeFilter = typeFilter;
        }

        /// <summary>
        /// Analyses the given type. 
        /// </summary>
        /// <param name="typeDefinition">The type to analyze as TypeDefinition</param>
        /// <returns>The type a TypeDescription</returns>
        internal TypeDescription AnalyseType(TypeDefinition typeDefinition)
        {
            if(m_TypeFilter != null && m_TypeFilter.IgnoreType(typeDefinition.FullName))
            {
                throw new ArgumentException("Do not analyze ignored types", nameof(typeDefinition));
            }

            var result = new TypeDescription(typeDefinition.FullName, typeDefinition.Module.Assembly.FullName);

            //Check for Attributes
            foreach (var typeDefinitionCustomAttribute in typeDefinition.CustomAttributes)
            {
                AddDependency(result, typeDefinitionCustomAttribute.AttributeType, new AttributeContext());
            }
            

            //Check fields
            foreach (var field in typeDefinition.Fields)
            {
                if (field.HasCustomAttributes &&
                    field.CustomAttributes.Any(i =>
                        i.AttributeType.FullName == typeof(CompilerGeneratedAttribute).FullName))
                {
                    continue;
                }
                AddDependency(result, field.FieldType, new FieldContext(field.Name));

                if (field.CustomAttributes != null)
                {
                    foreach (var fieldAttribute in field.CustomAttributes)
                    {
                        AddDependency(result, fieldAttribute.AttributeType, new FieldAttributeContext(field.Name));
                    }
                }
            }

            foreach (var property in typeDefinition.Properties)
            {

                if (property.HasCustomAttributes &&
                    property.CustomAttributes.Any(i =>
                        i.AttributeType.FullName == typeof(CompilerGeneratedAttribute).FullName))
                {
                    continue;
                }
                AddDependency(result, property.PropertyType, new FieldContext(property.Name));

                foreach (var fieldAttribute in property.CustomAttributes)
                {
                    AddDependency(result, fieldAttribute.AttributeType, new FieldAttributeContext(property.Name));
                }
            }

            // interfaces
            foreach (var implementedInterface in typeDefinition.Interfaces)
            {
                AddDependency(result, implementedInterface.InterfaceType, new InheritesContext());
            }

            // base class 
            if (typeDefinition.BaseType != null)
            {
                AddDependency(result, typeDefinition.BaseType, new InheritesContext());
            }

            foreach (var eventDefinition in typeDefinition.Events)
            {
                AddDependency(result, eventDefinition.EventType, new MethodDefinitionReturnTypeContext(eventDefinition.Name));    
                foreach (var eventCustomAttribute in eventDefinition.CustomAttributes)
                {
                    AddDependency(result, eventCustomAttribute.AttributeType, new MethodAttributeContext(eventDefinition.Name));
                }
            }

            
            AnalyseMethod(result, typeDefinition);

            return result;
        }

        private void AnalyseMethod(TypeDescription result, TypeDefinition typeDefinition)
        {
            foreach (var method in typeDefinition.Methods)
            {
                bool skipRest = false;
                //Check for Attributes, if the method is compiler generated, skip the rest
                // Do the CustomAttributes first, because the user may specify attributes at a {get;set;} and this attributes
                // are placed at the autogenerated methods
                foreach (var methodAttribute in method.CustomAttributes)
                {
                    AddDependency(result, methodAttribute.AttributeType, new MethodAttributeContext(method.Name));
                    if (methodAttribute.AttributeType.FullName == typeof(CompilerGeneratedAttribute).FullName)
                    {
                        skipRest = true;
                    }
                }

                if (skipRest)
                {
                    continue;
                }

                foreach (var parameter in method.Parameters)
                {
                    AddDependency(result, parameter.ParameterType, new MethodDefinitionParameterContext(method.Name));

                    //Check for Attributes
                    foreach (var methodAttribute in parameter.CustomAttributes)
                    {
                        AddDependency(result, methodAttribute.AttributeType, new MethodAttributeContext(method.Name));
                    }
                }

                var returnValue = method.MethodReturnType.ReturnType;
                // Durchlaufen Sie alle Attribute am Rückgabewert  
                foreach (var attribute in method.MethodReturnType.CustomAttributes)
                {
                    AddDependency(result, attribute.AttributeType, new MethodAttributeContext(method.Name));
                }
                if (returnValue.FullName != "System.Void")
                {
                    AddDependency(result, returnValue,  new MethodDefinitionReturnTypeContext(method.Name));
                }

                if (method.HasBody)
                {
                    AnalyseMethodBody(result, method);
                }


                
               

            }
        }

        private void AnalyseMethodBody(TypeDescription result, MethodDefinition method)
        {
            foreach (var localVariable in method.Body.Variables)
            {
                AddDependency(result, localVariable.VariableType, new MethodDefinitionLocalVariableContext(method.Name));
            }

            foreach (Mono.Cecil.Cil.Instruction line in method.Body.Instructions)
            {
                AnalyseMethodInstruction(result, method, line);
            }
        }

        private void AnalyseMethodInstruction(TypeDescription result, MethodDefinition method, Mono.Cecil.Cil.Instruction line) 
        {
            if (line.Operand is FieldDefinition fieldDefinition)
            {
                // this may not be relevant for the dependency if its a local field, but may be used for deeper informations
                var context = new MethodBodyFieldReferenceContext(method.Name, fieldDefinition.FullName);
                AddDependency(result, fieldDefinition.FieldType, context);
            }

            if (line.Operand is TypeDefinition accessTypeDefinition)
            {
                var context = new MethodBodyTypeReferenceContext(method.Name);
                AddDependency(result, accessTypeDefinition, context);
            }

            if (line.Operand is MethodDefinition methodDefinition)
            {
                var context = new MethodBodyCallMethodAtType(method.Name, methodDefinition.FullName);
                AddDependency(result, methodDefinition.DeclaringType, context);
            }
            
            if (line.Operand is MethodReference methodReference)
            {
                AnalyseMethodReference(result, method, methodReference);
            }
        }

        private void AnalyseMethodReference(TypeDescription result, MethodDefinition method, MethodReference methodReference)
        { 
            if (methodReference.ReturnType.FullName != "System.Void")
            {
                var context = new MethodBodyCalledMethodReturnTypeContext(method.Name, methodReference.FullName);
                AddDependency(result, methodReference.ReturnType, context);
            }

            foreach (var t in methodReference.Parameters)
            {
                var context = new MethodBodyCalledMethodParameterContext(method.Name, methodReference.FullName);
                AddDependency(result, t.ParameterType, context);
            }
        }

        private void AddDependency(TypeDescription currentType, TypeReference dependency, IDependencyContext context)
        {
            if (m_TypeFilter != null && m_TypeFilter.IgnoreTypeAsDependency(dependency.FullName))
            {
                return;
            }

            var dependencies = GetDependency(dependency);
                            
            foreach (var type in dependencies)
            {
                var d = type.Module.Assembly.FullName;
                var dependencyDescription = new TypeDescription(type.FullName, d);
                currentType.AddDependency(dependencyDescription, context);
            }
        }

        private static IEnumerable<TypeReference> GetDependency(TypeReference dependency)
        {
            List<TypeReference> result = new List<TypeReference>();

            if (dependency.IsArray)
            {
                var arrayType = dependency as ArrayType;
                result.AddRange(GetDependency(arrayType.ElementType));
            }
            else if (dependency.IsGenericInstance)
            {
                var genericType = AnalyseGeneric(dependency);
                foreach (var type in genericType)
                {
                    result.AddRange(GetDependency(type));
                }
            }
            else
            {
                result.Add(dependency);
            }

            return result;
        }

        private static IEnumerable<TypeReference> AnalyseGeneric(TypeReference dependency)
        {
            List<TypeReference> result = new List<TypeReference>();

            if (dependency is GenericInstanceType generic)
            {
                result.Add(generic.ElementType);
                result.AddRange(generic.GenericArguments);
            }

            return result;

        }

    }

    internal class FieldAttributeContext : DependencyContextBase
    {
        public FieldAttributeContext(string fieldName) : base(fieldName)
        {
        }
        
        public override void Visit(IDependencyContextVisitor visitor)
        {
            visitor.FieldAttribute(Name);
        }

        public override T Visit<T>(IDependencyContextVisitor<T> visitor)
        {
            return visitor.FieldAttribute(Name);
        }
    }
}
